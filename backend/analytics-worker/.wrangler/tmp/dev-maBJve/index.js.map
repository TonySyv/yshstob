{
  "version": 3,
  "sources": ["../bundle-csGWr0/strip-cf-connecting-ip-header.js", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-csGWr0/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-csGWr0/middleware-loader.entry.ts"],
  "sourceRoot": "W:\\yshstob\\backend\\analytics-worker\\.wrangler\\tmp\\dev-maBJve",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/**\r\n * Analytics Worker - Tracks redirect events and provides metrics\r\n * \r\n * Routes:\r\n * - POST /analytics/redirect - Receive redirect events\r\n * - GET /speedometer - Get metrics JSON\r\n * - PATCH /metadata/deploy - Update deploy metadata\r\n */\r\n\r\ninterface Env {\r\n  KV_ANALYTICS: KVNamespace;\r\n}\r\n\r\ninterface AnalyticsEvent {\r\n  code: string;\r\n  longUrl: string;\r\n  timestamp: number;\r\n  redirectTimeMs: number;\r\n  region?: string;\r\n  version?: string;\r\n}\r\n\r\ninterface Counters {\r\n  total_redirects: number;\r\n  total_ms: number;\r\n  version: string;\r\n  deploy_timestamp: string;\r\n  commit_summary: string;\r\n}\r\n\r\ninterface SpeedometerResponse {\r\n  version: string;\r\n  deploy_timestamp: string;\r\n  commit_summary: string;\r\n  total_redirects: number;\r\n  average_redirect_ms: number;\r\n}\r\n\r\ninterface DeployMetadata {\r\n  version: string;\r\n  commit_summary: string;\r\n  deploy_timestamp: string;\r\n}\r\n\r\n// KV Keys\r\nconst KEY_TOTAL_REDIRECTS = 'analytics:total_redirects';\r\nconst KEY_TOTAL_MS = 'analytics:total_ms';\r\nconst KEY_VERSION = 'analytics:version';\r\nconst KEY_DEPLOY_TIMESTAMP = 'analytics:deploy_timestamp';\r\nconst KEY_COMMIT_SUMMARY = 'analytics:commit_summary';\r\n\r\n// Default values\r\nconst DEFAULT_COUNTERS: Counters = {\r\n  total_redirects: 0,\r\n  total_ms: 0,\r\n  version: 'v1.000',\r\n  deploy_timestamp: new Date().toISOString(),\r\n  commit_summary: 'Initial deployment',\r\n};\r\n\r\n/**\r\n * CORS headers\r\n */\r\nconst corsHeaders = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Methods': 'GET, POST, PATCH, OPTIONS',\r\n  'Access-Control-Allow-Headers': 'Content-Type',\r\n  'Access-Control-Max-Age': '86400',\r\n};\r\n\r\n/**\r\n * Handle CORS preflight (OPTIONS) requests\r\n */\r\nfunction handleCorsPreflight(): Response {\r\n  return new Response(null, {\r\n    status: 204,\r\n    headers: corsHeaders,\r\n  });\r\n}\r\n\r\n/**\r\n * Add CORS headers to a response\r\n */\r\nfunction addCorsHeaders(response: Response): Response {\r\n  const newResponse = new Response(response.body, response);\r\n  Object.entries(corsHeaders).forEach(([key, value]) => {\r\n    newResponse.headers.set(key, value);\r\n  });\r\n  return newResponse;\r\n}\r\n\r\n/**\r\n * Read counters from KV\r\n */\r\nasync function readCounters(env: Env): Promise<Counters> {\r\n  const [\r\n    totalRedirectsStr,\r\n    totalMsStr,\r\n    version,\r\n    deployTimestamp,\r\n    commitSummary,\r\n  ] = await Promise.all([\r\n    env.KV_ANALYTICS.get(KEY_TOTAL_REDIRECTS),\r\n    env.KV_ANALYTICS.get(KEY_TOTAL_MS),\r\n    env.KV_ANALYTICS.get(KEY_VERSION),\r\n    env.KV_ANALYTICS.get(KEY_DEPLOY_TIMESTAMP),\r\n    env.KV_ANALYTICS.get(KEY_COMMIT_SUMMARY),\r\n  ]);\r\n\r\n  return {\r\n    total_redirects: totalRedirectsStr ? parseInt(totalRedirectsStr, 10) : DEFAULT_COUNTERS.total_redirects,\r\n    total_ms: totalMsStr ? parseInt(totalMsStr, 10) : DEFAULT_COUNTERS.total_ms,\r\n    version: version || DEFAULT_COUNTERS.version,\r\n    deploy_timestamp: deployTimestamp || DEFAULT_COUNTERS.deploy_timestamp,\r\n    commit_summary: commitSummary || DEFAULT_COUNTERS.commit_summary,\r\n  };\r\n}\r\n\r\n/**\r\n * Write counters to KV\r\n */\r\nasync function writeCounters(env: Env, counters: Partial<Counters>): Promise<void> {\r\n  const updates: Promise<void>[] = [];\r\n\r\n  if (counters.total_redirects !== undefined) {\r\n    updates.push(env.KV_ANALYTICS.put(KEY_TOTAL_REDIRECTS, counters.total_redirects.toString()));\r\n  }\r\n  if (counters.total_ms !== undefined) {\r\n    updates.push(env.KV_ANALYTICS.put(KEY_TOTAL_MS, counters.total_ms.toString()));\r\n  }\r\n  if (counters.version !== undefined) {\r\n    updates.push(env.KV_ANALYTICS.put(KEY_VERSION, counters.version));\r\n  }\r\n  if (counters.deploy_timestamp !== undefined) {\r\n    updates.push(env.KV_ANALYTICS.put(KEY_DEPLOY_TIMESTAMP, counters.deploy_timestamp));\r\n  }\r\n  if (counters.commit_summary !== undefined) {\r\n    updates.push(env.KV_ANALYTICS.put(KEY_COMMIT_SUMMARY, counters.commit_summary));\r\n  }\r\n\r\n  await Promise.all(updates);\r\n}\r\n\r\n/**\r\n * Compute average redirect time\r\n */\r\nfunction computeAverage(totalMs: number, totalRedirects: number): number {\r\n  if (totalRedirects === 0) {\r\n    return 0;\r\n  }\r\n  return totalMs / totalRedirects;\r\n}\r\n\r\n/**\r\n * Handle POST /analytics/redirect\r\n */\r\nasync function handleAnalyticsRedirect(\r\n  request: Request,\r\n  env: Env\r\n): Promise<Response> {\r\n  try {\r\n    const event: AnalyticsEvent = await request.json();\r\n\r\n    // Validate event\r\n    if (!event.code || !event.longUrl || !event.timestamp) {\r\n      return addCorsHeaders(new Response(\r\n        JSON.stringify({ error: 'Invalid event data' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      ));\r\n    }\r\n\r\n    // Read current counters\r\n    const counters = await readCounters(env);\r\n\r\n    // Use redirect time from event (in milliseconds)\r\n    const redirectTimeMs = event.redirectTimeMs || 0;\r\n\r\n    // Update counters atomically\r\n    await writeCounters(env, {\r\n      total_redirects: counters.total_redirects + 1,\r\n      total_ms: counters.total_ms + redirectTimeMs,\r\n    });\r\n\r\n    return addCorsHeaders(new Response(\r\n      JSON.stringify({ success: true }),\r\n      { status: 200, headers: { 'Content-Type': 'application/json' } }\r\n    ));\r\n  } catch (error) {\r\n    return addCorsHeaders(new Response(\r\n      JSON.stringify({ error: 'Internal server error' }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    ));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle GET /speedometer\r\n */\r\nasync function handleSpeedometer(env: Env): Promise<Response> {\r\n  try {\r\n    const counters = await readCounters(env);\r\n    const averageMs = computeAverage(counters.total_ms, counters.total_redirects);\r\n\r\n    const response: SpeedometerResponse = {\r\n      version: counters.version,\r\n      deploy_timestamp: counters.deploy_timestamp,\r\n      commit_summary: counters.commit_summary,\r\n      total_redirects: counters.total_redirects,\r\n      average_redirect_ms: Math.round(averageMs * 1000) / 1000, // Round to 3 decimal places\r\n    };\r\n\r\n    return addCorsHeaders(new Response(JSON.stringify(response), {\r\n      status: 200,\r\n      headers: { 'Content-Type': 'application/json' },\r\n    }));\r\n  } catch (error) {\r\n    return addCorsHeaders(new Response(\r\n      JSON.stringify({ error: 'Internal server error' }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    ));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle PATCH /metadata/deploy\r\n */\r\nasync function handleDeployMetadata(\r\n  request: Request,\r\n  env: Env\r\n): Promise<Response> {\r\n  try {\r\n    const metadata: DeployMetadata = await request.json();\r\n\r\n    // Validate metadata\r\n    if (!metadata.version || !metadata.deploy_timestamp) {\r\n      return addCorsHeaders(new Response(\r\n        JSON.stringify({ error: 'Missing required fields: version, deploy_timestamp' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      ));\r\n    }\r\n\r\n    // Update metadata in KV\r\n    await writeCounters(env, {\r\n      version: metadata.version,\r\n      deploy_timestamp: metadata.deploy_timestamp,\r\n      commit_summary: metadata.commit_summary || 'No commit message',\r\n    });\r\n\r\n    return addCorsHeaders(new Response(\r\n      JSON.stringify({ success: true }),\r\n      { status: 200, headers: { 'Content-Type': 'application/json' } }\r\n    ));\r\n  } catch (error) {\r\n    return addCorsHeaders(new Response(\r\n      JSON.stringify({ error: 'Internal server error' }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    ));\r\n  }\r\n}\r\n\r\n/**\r\n * Main fetch handler\r\n */\r\nexport default {\r\n  async fetch(\r\n    request: Request,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const path = url.pathname;\r\n\r\n    // Handle CORS preflight\r\n    if (request.method === 'OPTIONS') {\r\n      return handleCorsPreflight();\r\n    }\r\n\r\n    // POST /analytics/redirect\r\n    if (request.method === 'POST' && path === '/analytics/redirect') {\r\n      return handleAnalyticsRedirect(request, env);\r\n    }\r\n\r\n    // GET /speedometer\r\n    if (request.method === 'GET' && path === '/speedometer') {\r\n      return handleSpeedometer(env);\r\n    }\r\n\r\n    // PATCH /metadata/deploy\r\n    if (request.method === 'PATCH' && path === '/metadata/deploy') {\r\n      return handleDeployMetadata(request, env);\r\n    }\r\n\r\n    // 404 for unknown routes\r\n    return addCorsHeaders(new Response(\r\n      JSON.stringify({ error: 'Not found' }),\r\n      { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n    ));\r\n  },\r\n};\r\n\r\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\src\\\\index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\.wrangler\\\\tmp\\\\bundle-csGWr0\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\.wrangler\\\\tmp\\\\bundle-csGWr0\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"W:\\\\yshstob\\\\backend\\\\analytics-worker\\\\.wrangler\\\\tmp\\\\bundle-csGWr0\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["stripCfConnectingIPHeader", "input", "init", "request", "__name", "target", "thisArg", "argArray", "KEY_TOTAL_REDIRECTS", "KEY_TOTAL_MS", "KEY_VERSION", "KEY_DEPLOY_TIMESTAMP", "KEY_COMMIT_SUMMARY", "DEFAULT_COUNTERS", "corsHeaders", "handleCorsPreflight", "__name", "addCorsHeaders", "response", "newResponse", "key", "value", "readCounters", "env", "totalRedirectsStr", "totalMsStr", "version", "deployTimestamp", "commitSummary", "writeCounters", "counters", "updates", "computeAverage", "totalMs", "totalRedirects", "handleAnalyticsRedirect", "request", "event", "redirectTimeMs", "handleSpeedometer", "averageMs", "handleDeployMetadata", "metadata", "src_default", "ctx", "path", "drainBody", "__name", "request", "env", "_ctx", "middlewareCtx", "reader", "e", "middleware_ensure_req_body_drained_default", "reduceError", "__name", "jsonError", "request", "env", "_ctx", "middlewareCtx", "e", "error", "middleware_miniflare3_json_error_default", "__INTERNAL_WRANGLER_MIDDLEWARE__", "middleware_ensure_req_body_drained_default", "middleware_miniflare3_json_error_default", "middleware_insertion_facade_default", "src_default", "__facade_middleware__", "__facade_register__", "args", "__name", "__facade_invokeChain__", "request", "env", "ctx", "dispatch", "middlewareChain", "head", "tail", "newRequest", "newEnv", "__name", "__facade_invoke__", "finalMiddleware", "__facade_middleware__", "__Facade_ScheduledController__", "scheduledTime", "cron", "noRetry", "#noRetry", "__name", "wrapExportedHandler", "worker", "__INTERNAL_WRANGLER_MIDDLEWARE__", "middleware", "__facade_register__", "fetchDispatcher", "request", "env", "ctx", "__facade_invoke__", "type", "init", "controller", "wrapWorkerEntrypoint", "klass", "#fetchDispatcher", "#dispatcher", "WRAPPED_ENTRY", "middleware_insertion_facade_default", "middleware_loader_entry_default"]
}
